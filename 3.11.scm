#!/bin/guile -l
!#

(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else
            (error "Unknown request: MAKE-ACCOUNT"
                   m))))
  dispatch)

Show the environment structure generated by the sequence of interactions

(define acc (make-account 50))

((acc 'deposit) 40)
90

((acc 'withdraw) 60)
30

Where is the local state for acc kept? Suppose we deÔ¨Åne another account:
(define acc2 (make-account 100))

How are the local states for the two accounts kept distinct?  Which parts of the
environment structure are shared between acc and acc2 ?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

* Evaluting the defintion:

        We bind make-account in the global enviorment to the procedure object
        with balance as a parameter, and a pointer to the global enviorment.

* Evaluating (define acc (make-account 50))

        We apply (make-account 50). This creates a new enviorment E1 that points
        to the global envriorment with the parameter balance bound to 50, and then we
        evalute the body.

        The body has defines withdraw deposit and dispatch. This creates three
        procedure objects with their respective parameters, and they're all pointing to
        the enviorment E1. Also, all names are bound inside E1. 

        After all of these defintions, we evaluate the actual body of
        make-account, which is dispatch, we don't know what dispatch is, so we
        look for it in e1 and find it's lambda expression, and bind it to acc.

((acc 'deposit) 50)

        We apply (acc 'deposit) first, this create a new frame e2, and bind m,
        which is the parameter of dispatch to 'deposit, and then evalute the body of
        dispatch, which is a condition statement that will return to us withdraw, but we
        don't know what withdraw is, so we look for it in the parent of dispatch, which
        is e1.

        This leaves us with (withdraw 50), this creates yet another frame e3,
        and binds the amount to 50, and does it's thing until it needs the value
        of balance, the value of balance can be found in the parent enviorment
        of withdraw which is e1, and then it runs set! which changes it.

Creating another account will create a different enviorment with different local
state. However, whether or not the lambda expressions will be shared in the
comptuer varries between implementations.
